script.
  // CATCH ANY ERRORS!
  var onErr = (err) => {
    if(global.packageInfo.updateAvailable) {
      $("#not-latest-stable").show();
      if (global.packageInfo.isSnap) {
        $("#snap-update-instructions-error").show();
      } else {
        $("#generic-update-instructions-error").show();
      }
    }
    $("#error-body").text(err);
    $("#error-modal").modal("show");
  }

  window.onerror = (err, url, line) => {
    onErr(err+" (MainRenderer:"+line+")");
  }

  ipcRenderer.on("user:error", (event, err) => { onErr(err); });

  ipcRenderer.on("user:write:working", (e, animation) => {
    views.show("working", animation);
  });

  ipcRenderer.on("user:connection-lost", (e, callback) => {
    modals.show("connection-lost");
    $("#btn-reconnect").click(callback);
  });

  ipcRenderer.on("user:low-power", (callback) => {
    modals.show("low-power");
  });

  var ignoreError = () => {
    ipcRenderer.send('error_ignored');
  }

  var restartInstaller = () => {
    ipcRenderer.send('restart');
  }

  ipcRenderer.on("user:oem-lock", (event) => {
    modals.show('oem-lock');
    $("#btn-unlock").click(() => {
      event.sender.send("user:oem-lock:ok");
      modals.hide('oem-lock');
      $("#btn-unlock").attr("disabled", true);
      $("#btn-exit").attr("disabled", true);
      $("#unlock-prog").removeClass("hidden");
    });
  });

  ipcRenderer.on("user:reboot", (e, i) => {
    views.show("reboot-" + i.button);
    $("[id=reboot-to-state]").text(i.state);
    $("#complex-reboot-instruction").text(i.instruction);
  });

  ipcRenderer.on("reboot:done", () => {
    $('#views-reboot-up').hide();
    $('#views-reboot-down').hide();
  });

  ipcRenderer.on("user:no-network", () => {
    modals.show('no-network');
  });

  ipcRenderer.on("user:write:speed", (e, speed) => {
    footer.speedText.set(speed);
  });

  ipcRenderer.on("user:write:progress", (e, length) => {
    if(length >= 100) {
      length=100;
    }
    $("#progress").show();
    $("#progress").width(length.toString()+"%");
  });

  ipcRenderer.on("user:write:done", () => {
    if (global.installProperties.cli) {
      remote.getCurrentWindow().close();
    } else {
      views.show("done");
      $("#progress").width("0%");
    }
  });

  ipcRenderer.on("user:write:status", (e, status, waitDots) => {
    footer.topText.set(status, waitDots);
  });

  ipcRenderer.on("user:write:under", (e, status) => {
    footer.underText.set(status, true);
  });

  ipcRenderer.on("user:device-unsupported", (event, device) => {
    footer.topText.set("Device not supported");
    footer.underText.set("The device " + device + " is not supported");
    $("[id=your-device]").text(device);
    views.show("not-supported");
  });

  ipcRenderer.on("user:os", (event, installConfig, osSelects) => {
    global.installConfig = installConfig;
    global.installConfig.os_to_install = undefined;
    $("#options-os").append(osSelects);
    $("#your-ubp-device").text(installConfig.name+" ("+installConfig.codename+")");
    $("#your-ubp-device").click(() => {
      shell.openExternal("https://devices.ubuntu-touch.io/device/" + installConfig.codename);
    });
    views.show("select-os");
  });

  views.show("working", "particles");

  ipcRenderer.on("device:wait:device-selects-ready", (event, deviceSelects) => {
    footer.topText.set("Waiting for device", true);
    footer.underText.set("Please connect your device with a USB cable");
    if (!remote.getGlobal("installProperties").device) {
      // if the device is not yet set (i.e. from a cli argument), prompt the user
      $("#device-select").append(deviceSelects);
      views.show("wait-for-device");
      // Button to confirm device selection
      $("#btn-select-device").click(() => {
        var device = $("#device-select").find(":selected").attr("name");
        ipcRenderer.send("device:selected", device);
      });
    } else {
      // if the device is set, just return the device:selected event
      ipcRenderer.send("device:selected", remote.getGlobal("installProperties").device);
    }
  });
